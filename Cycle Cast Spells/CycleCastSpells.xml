<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, December 15, 2024, 11:14 PM -->
<!-- MuClient version 5.07-pre -->

<muclient>
<plugin
   name="CycleCastSpells"
   author="Khrysis"
   id="74b124cb16d29c3f9a369ae4"
   language="Lua"
   purpose="cycle atks in lists you create"
   save_state="y"
   date_written="2024-12-15 23:12:46"
   requires="5.07"
   version="1.21"
   >
   <description trim="y">
<![CDATA[
============================================================================
                     CYCLE CAST SPELLS CHANGE LOG
============================================================================
v1.210
- Rotation Support: Create multi-spell "cycles" for complex combat.
- Targeting: Use 'ccx' to fire your next rotation spell on a target.
- Enhanced UI: 'cc list' now shows full rotation paths with [NEXT] markers.
- Auto-Saving: All your custom rotations persist between sessions.

COMMANDS:
* cc add <spell> <group> : Add a spell/skill to a rotation group.
* cc <group>             : Fire the next spell in the cycle.
* ccx <group> <target>   : Fire the next spell on a specific target.
* cc list                : Display all rotations and current positions.
* cc help                : View detailed usage and pro-tips.
============================================================================
]]>
</description>

</plugin>

<aliases>
  <alias 
  match="cc update check" 
  enabled="y" 
  script="update_check_alias" 
  sequence="99"
  >
  </alias>
  
  <alias 
  match="cc update install" 
  enabled="y" 
  script="update_install_alias" 
  sequence="99"
  >
  </alias>
  
  <alias
   script="OnHelp"
   match="^cc help$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
  
  <alias
   match="^cc list$"
   enabled="y" 
   send_to="12"
   regexp="y" 
   sequence="100" 
   ignore_case="y"
   script="DisplaySpellList"
  >
  </alias>
  
  <alias
   match="^cc add (.*) (.*)$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
   script="AddSpell"
  >
  </alias>
  
  <alias
   match="^cc rem (.*) (.*)$"
   enabled="y" 
   regexp="y" 
   sequence="100"
   ignore_case="y"
   script="RemoveSpell"
  >
  </alias>

  <alias
   match="^cc clear (.*)$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
   script="ClearSpells"
  >
  </alias>

  <alias
   match="^cc (?!help|add|rem|list|clear|update)(.*)$"
   enabled="y"
   regexp="y"
   sequence="105"
   ignore_case="y"
   script="CastCycle"
  >
  </alias>

  <alias
   match="^ccx (.*) (.*)$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
   script="CastCycle"
  >
  </alias>

</aliases>

<script>
<![CDATA[
require "serialize"

spellsTable = {}  -- A table to store spells by their element type
currentIndexes = {}  -- A table to store current indexes for each element

-- Cast Cycle or the cc command stuff for ccx and cc

function CastCycle (name, line, wildcards)
    local element = string.lower(wildcards[1])
    local target = wildcards[2] -- Will be nil for 'cc', or the mob name for 'ccx'

    if spellsTable[element] then
        -- Initialize index if it doesn't exist
        currentIndexes[element] = currentIndexes[element] or 1
        
        -- Safety check: if index somehow got higher than the table size, reset it
        if currentIndexes[element] > #spellsTable[element] then
            currentIndexes[element] = 1
        end
        
        local spell = spellsTable[element][currentIndexes[element]]
        
        -- Build and send the command
        local cmd = "cast '" .. spell .. "'"
        if target and target ~= "" then
            cmd = cmd .. " " .. target
        end
        Send(cmd)
        
        -- Professional Feedback
        ColourTell("silver", "", "[", "cyan", "", "CycleCast", "silver", "", "] Casting: ", "white", "", spell)
        if target then
            ColourNote("silver", "", " on ", "yellow", "", target)
        else
            Note("") -- Just finishes the line
        end

        -- Move to the next spell
        currentIndexes[element] = currentIndexes[element] + 1
        if currentIndexes[element] > #spellsTable[element] then
            currentIndexes[element] = 1 
        end
    else
        ColourNote("orange", "", " [!] ", "white", "", "No rotation found for group: ", "cyan", "", element)
    end
end

-- Clear Spells or cc clear

function ClearSpells (name, line, wildcards)
    local target = string.lower(wildcards[1])
    
    if target == "all" then
        spellsTable = {}
        currentIndexes = {}
        ColourNote("red", "black", " ALL ", "white", "", " rotation categories and spells have been deleted.")
    elseif spellsTable[target] then
        spellsTable[target] = nil
        currentIndexes[target] = 1
        ColourNote("yellow", "", "Cleared all spells for the group: ", "cyan", "", target)
    else
        ColourNote("orange", "", "Group '", "white", "", target, "orange", "", "' not found. Nothing to clear.")
    end
end

-- Remove Spell or cc rem

function RemoveSpell (name, line, wildcards)
    local spell_to_remove = wildcards[1]:lower()
    local element = wildcards[2]:lower()

    if not spellsTable[element] then
        ColourNote("orange", "", "Group '", "cyan", "", element, "orange", "", "' does not exist.")
        return
    end

    local foundIndex = nil
    for i, spell in ipairs(spellsTable[element]) do
        if spell:lower() == spell_to_remove then
            foundIndex = i
            break
        end
    end

    if foundIndex then
        local removed = table.remove(spellsTable[element], foundIndex)
        ColourNote("red", "", "Removed '", "white", "", removed, "red", "", "' from the ", "cyan", "", element, "red", "", " list.")
        
        -- Reset index to 1 if the list is now empty or if index is out of bounds
        if #spellsTable[element] == 0 then
            currentIndexes[element] = 1
        elseif (currentIndexes[element] or 1) > #spellsTable[element] then
            currentIndexes[element] = 1
        end
    else
        ColourNote("yellow", "", "Spell '", "white", "", wildcards[1], "yellow", "", "' was not found in the ", "cyan", "", element, "yellow", "", " list.")
    end
end

-- Add spell to list or cc add function

function AddSpell (name, line, wildcards)
    local spell = wildcards[1]
    local element = string.lower(wildcards[2]) -- Automatically makes group name lowercase

    -- Ensure the element table exists
    if not spellsTable[element] then
        spellsTable[element] = {}
        currentIndexes[element] = 1
    end

    -- Check for duplicates
    local exists = false
    for _, v in ipairs(spellsTable[element]) do
        if v:lower() == spell:lower() then
            exists = true
            break
        end
    end

    if exists then
        ColourNote("yellow", "", "The spell '", "white", "", spell, "yellow", "", "' is already in the ", "cyan", "", element, "yellow", "", " list.")
    else
        table.insert(spellsTable[element], spell)
        ColourNote("lime", "", "Added '", "white", "", spell, "lime", "", "' to the ", "cyan", "", element, "lime", "", " rotation.")
    end
end

-- Display spells list or the cc list

function DisplaySpellList (name, line, wildcards)
    if next(spellsTable) == nil then
        ColourNote("yellow", "", " [!] ", "white", "", "No spell rotations found. Use ", "cyan", "", "cc add <spell> <group>", "white", "", " to start.")
        return
    end

    local divider = "-------------------------------------------------------------------------------"
    ColourNote("orange", "", divider)
    ColourNote("white", "", string.format("%-15s | %-5s | %-40s", "Group", "Index", "Spell Rotation"))
    ColourNote("orange", "", divider)

    for element, spells in pairs(spellsTable) do
        local currentIdx = currentIndexes[element] or 1
        local spellList = ""
        
        for i, spell in ipairs(spells) do
            if i == currentIdx then
                spellList = spellList .. "[" .. spell:upper() .. "]"
            else
                spellList = spellList .. spell
            end
            
            if i < #spells then
                spellList = spellList .. " -> "
            end
        end

        -- Use ColourTell for the parts that stay on the SAME line
        -- Use ColourNote ONLY for the final part to move to the NEXT line
        ColourTell("cyan", "", string.format("%-15s", element))
        ColourTell("silver", "", " | ")
        ColourTell("yellow", "", string.format("  %-3d", currentIdx))
        ColourTell("silver", "", " | ")
        ColourNote("white", "", spellList) -- This one finishes the line
    end
    
    ColourNote("orange", "", divider)
    ColourNote("silver", "", "Note: Spells in ", "white", "", "[BRACKETS]", "silver", "", " are up next in the cycle.")
end

-- Help function

function OnHelp ()
  local p = "CycleCastSpells"
  local version = string.format("%1.2f", GetPluginInfo(GetPluginID(), 19) or 0)
  local line = "==============================================================================="
  
  ColourNote("orange", "", line)
  ColourNote("yellow", "", "Plugin: " .. p .. " (v" .. version .. ") - Help File")
  Note("")
  
  -- Core Commands
  ColourNote("cyan", "", "cc add <spell> <group>  ") ColourNote("white", "", "- Add a spell to a rotation")
  ColourNote("cyan", "", "cc rem <spell> <group>  ") ColourNote("white", "", "- Remove a specific spell from a group")
  ColourNote("cyan", "", "cc list                 ") ColourNote("white", "", "- View all your saved rotations")
  ColourNote("cyan", "", "cc clear <group>        ") ColourNote("white", "", "- Delete a specific group")
  ColourNote("cyan", "", "cc clear all            ") ColourNote("white", "", "- Wipe all data and start over")
  Note("")

  -- Casting Commands
  ColourNote("cyan", "", "cc <group>              ") ColourNote("white", "", "- Cast the next spell in that cycle")
  ColourNote("cyan", "", "ccx <group> <target>    ") ColourNote("white", "", "- Cast next spell on a specific mob/player")
  Note("")

  -- Maintenance Commands
  ColourNote("cyan", "", "cc update check         ") ColourNote("white", "", "- Check GitHub for a newer version")
  ColourNote("cyan", "", "cc update install       ") ColourNote("white", "", "- Download and install the latest update")
  Note("")
  
  -- Advanced Examples
  ColourNote("lime", "", "PRO TIPS & EXAMPLES:")
  
  -- Example 1
  ColourNote("silver", "", " * ") 
  ColourNote("yellow", "", "Complex Rotations: ") 
  Note("Add multiple spells to one letter for easy spamming.")
  Note("   cc add magic missile 1; cc add ice bolt 1; cc add shock 1")
  Note("   Now just spam 'cc 1' to rotate through three different elements.")
  
  -- Example 2
  ColourNote("silver", "", " * ") 
  ColourNote("yellow", "", "Targeting: ") 
  Note("Use 'ccx' to start a fight. Example: 'ccx debuff fido'")
  
  -- Example 3
  ColourNote("silver", "", " * ") 
  ColourNote("yellow", "", "Multi-word Spells: ") 
  Note("Do NOT use quotes. The plugin handles spaces automatically.")
  Note("Example: cc add acid wave f")
  
  ColourNote("orange", "", line)
end

-- Saving things

function OnPluginSaveState ()
  -- Save both spellsTable and currentIndexes
  SetVariable("spellsTable", "spellsTable = " .. serialize.save_simple(spellsTable))
  SetVariable("currentIndexes", "currentIndexes = " .. serialize.save_simple(currentIndexes))
end

function OnPluginInstall()
  -- Print the basic install message
  ColourNote("blue", "yellow", "[CC] CycleCastSpells Installed/Reloaded!")
  
  -- Display the "What's New" or Command List from the description tag
  Note("")
  ColourNote("cyan", "", GetPluginInfo(GetPluginID(), 3))
  Note("")
  
  -- Load Saved Data
  assert(loadstring(GetVariable("spellsTable") or "--"))()
  assert(loadstring(GetVariable("currentIndexes") or "--"))()
end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Khrysis-aard/aardwolf-mushclient-plugins/refs/heads/main/Cycle%20Cast%20Spells/CycleCastSpells.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[CycleCastSpells]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("yellow", "", plugin_prefix .. "","white",""," Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("yellow", "", plugin_prefix .. "","white",""," Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You are running the most recent version. (","cyan","","v" .. currentVerStr .. "","white","",")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You have a newer version than is publicly available. (","cyan","","v" .. currentVerStr .. "","white","",")")
     elseif (update_mode == "check") then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You are running ","cyan","","v" .. currentVerStr .. "","white",""," , but there's a newer version ","cyan","","v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," Updating plugin from version ","cyan","", currentVerStr .. "","white",""," to version ","cyan","", remoteVerStr .."") 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------
]]>
</script>

</muclient>

